from typing import Optional, List
from toaster.broker.events import Event
from toaster.keyboards import Keyboard, ButtonColor, Callback
from rules import requires_mark, requires_permission, requires_attachments
from data import UserPermission, PeerMark
from .base import BaseCommand


@requires_permission(UserPermission.administrator)
class Mark(BaseCommand):
    NAME = "mark"

    def _handle(self, name: str, args: Optional[List[str]], event: Event) -> bool:
        answer_text = (
            "âš ï¸ Ğ’Ñ‹ Ñ…Ğ¾Ñ‚Ğ¸Ñ‚Ğµ Ğ·Ğ°Ğ´Ğ°Ñ‚ÑŒ Ğ¼ĞµÑ‚ĞºÑƒ Ğ±ĞµÑĞµĞ´Ğµ? \n\n"
            "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾Ğµ Ğ´ĞµÑÑ‚Ğ²Ğ¸Ğµ Ğ¸Ğ· Ğ¼ĞµĞ½Ñ Ğ½Ğ¸Ğ¶Ğµ:"
        )

        keyboard = (
            Keyboard(inline=True, one_time=False, owner_id=event.user.uuid)
            .add_row()
            .add_button(
                Callback(
                    label="CHAT", payload={"action_name": "set_mark", "mark": "CHAT"}
                ),
                ButtonColor.POSITIVE,
            )
            .add_button(
                Callback(
                    label="LOG", payload={"action_name": "set_mark", "mark": "LOG"}
                ),
                ButtonColor.POSITIVE,
            )
            .add_row()
            .add_button(
                Callback(
                    label="ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ Ğ±ĞµÑĞµĞ´Ñ‹",
                    payload={"action_name": "update_peer_data"},
                ),
                ButtonColor.SECONDARY,
            )
            .add_row()
            .add_button(
                Callback(label="Ğ¡Ğ±Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ Ğ¼ĞµÑ‚ĞºÑƒ", payload={"action_name": "drop_mark"}),
                ButtonColor.NEGATIVE,
            )
            .add_button(
                Callback(label="Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ", payload={"action_name": "close_menu"}),
                ButtonColor.NEGATIVE,
            )
        )

        answer = self.api.messages.send(
            peer_ids=event.peer.bpid,
            random_id=0,
            message=answer_text,
            keyboard=keyboard.json,
        )

        return True


@requires_mark(PeerMark.CHAT)
@requires_permission(UserPermission.administrator)
class Permission(BaseCommand):
    NAME = "permission"

    def _handle(self, name: str, args: Optional[List[str]], event: Event) -> bool:
        if not args or not self.is_tag(user_tag := args[0]):
            return False

        answer_text = (
            f"âš ï¸ Ğ£Ñ€Ğ¾Ğ²Ğ½Ğ¸ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ° Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ {user_tag} \n\n"
            "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾Ğµ Ğ´ĞµÑÑ‚Ğ²Ğ¸Ğµ Ğ¸Ğ· Ğ¼ĞµĞ½Ñ Ğ½Ğ¸Ğ¶Ğµ:"
        )

        keyboard = (
            Keyboard(inline=True, one_time=False, owner_id=event.user.uuid)
            .add_row()
            .add_button(
                Callback(
                    label="ĞœĞ¾Ğ´ĞµÑ€Ğ°Ñ‚Ğ¾Ñ€",
                    payload={
                        "action_name": "set_permission",
                        "permission": 1,
                        "target": self.id_from_tag(user_tag),
                    },
                ),
                ButtonColor.POSITIVE,
            )
            .add_button(
                Callback(
                    label="ĞĞ´Ğ¼Ğ¸Ğ½Ğ¸ÑÑ‚Ñ€Ğ°Ñ‚Ğ¾Ñ€",
                    payload={
                        "action_name": "set_permission",
                        "permission": 2,
                        "target": self.id_from_tag(user_tag),
                    },
                ),
                ButtonColor.POSITIVE,
            )
            .add_button(
                Callback(
                    label="Ğ¡Ğ±Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ",
                    payload={
                        "action_name": "drop_permission",
                        "target": self.id_from_tag(user_tag),
                    },
                ),
                ButtonColor.NEGATIVE,
            )
            .add_row()
            .add_button(
                Callback(label="Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ", payload={"action_name": "close_menu"}),
                ButtonColor.NEGATIVE,
            )
        )

        send_info = self.api.messages.send(
            peer_ids=event.peer.bpid,
            random_id=0,
            message=answer_text,
            keyboard=keyboard.json,
        )

        # TODO: Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ ÑĞµÑÑĞ¸Ñ Ğ¼ĞµĞ½Ñ

        return True


@requires_mark(PeerMark.CHAT)
@requires_permission(UserPermission.moderator)
class Say(BaseCommand):
    NAME = "say"

    def _handle(self, name: str, args: Optional[List[str]], event: Event) -> bool:
        if not args:
            return False

        answer_text = " ".join(args)

        self.api.messages.send(
            peer_ids=event.peer.bpid,
            random_id=0,
            message=answer_text,
        )

        return True


@requires_mark(PeerMark.CHAT)
@requires_attachments("reply", "forward")
@requires_permission(UserPermission.moderator)
class Delete(BaseCommand):
    NAME = "delete"

    def _handle(self, name: str, args: Optional[List[str]], event: Event) -> bool:
        if "reply" in event.message.attachments:
            self.api.messages.delete(
                delete_for_all=1,
                cmids=event.message.reply.cmid,
                peer_id=event.peer.bpid,
            )

        elif "forward" in event.message.attachments:
            for reply in event.message.forward:
                self.api.messages.delete(
                    delete_for_all=1,
                    cmids=reply.cmid,
                    peer_id=event.peer.bpid,
                )
        else:
            return False

        return True


@requires_mark(PeerMark.CHAT)
class Game(BaseCommand):
    NAME = "game"

    def _handle(self, name: str, args: Optional[List[str]], event: Event) -> bool:
        answer_text = "ğŸ² ĞŸĞ¾Ñ‚ÑĞ½ÑƒĞ»Ğ¾ Ğ½Ğ° Ğ°Ğ·Ğ°Ñ€Ñ‚? :)\n\n" "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ¸Ğ³Ñ€Ñƒ Ğ¸Ğ· ÑĞ¿Ğ¸ÑĞºĞ° Ğ½Ğ¸Ğ¶Ğµ:"

        keyboard = (
            Keyboard(inline=True, one_time=False, owner_id=event.user.uuid)
            .add_row()
            .add_button(
                Callback(label="Ğ ÑƒĞ»ĞµÑ‚ĞºĞ°", payload={"action_name": "game_roll"}),
                ButtonColor.PRIMARY,
            )
            .add_row()
            .add_button(
                Callback(
                    label="Ğ‘Ñ€Ğ¾ÑĞ¾Ğº Ğ¼Ğ¾Ğ½ĞµÑ‚ĞºĞ¸", payload={"action_name": "game_coinflip"}
                ),
                ButtonColor.PRIMARY,
            )
            .add_row()
            .add_button(
                Callback(label="Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ", payload={"action_name": "close_menu"}),
                ButtonColor.NEGATIVE,
            )
        )

        send_info = self.api.messages.send(
            peer_ids=event.get("peer_id"),
            random_id=0,
            message=answer_text,
            keyboard=keyboard.json,
        )

        # TODO: Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ ÑĞµÑÑĞ¸Ñ Ğ¼ĞµĞ½Ñ

        return True


@requires_mark(PeerMark.CHAT)
@requires_attachments("reply")
@requires_permission(UserPermission.moderator)
class Copy(BaseCommand):
    NAME = "copy"

    def _handle(self, name: str, args: Optional[List[str]], event: Event) -> bool:
        self.api.messages.send(
            peer_ids=event.peer.bpid,
            random_id=0,
            message=event.message.reply.text,
        )
        return True
